{"ast":null,"code":"import { createBlock, blockManager } from './block.js'; // even though the file has .ts extension, we need to use .js for resolution.\nimport { resolveManager } from './resolve.js';\nimport { pluginManager } from './plugin.js';\nimport { actionManager } from './action.js';\nexport var BlockTypes;\n(function (BlockTypes) {\n  BlockTypes[\"ACTION\"] = \"action\";\n  BlockTypes[\"MESSAGE\"] = \"message\";\n})(BlockTypes = BlockTypes || (BlockTypes = {}));\nexport const BOTUI_BLOCK_TYPES = BlockTypes;\nexport const createBot = () => {\n  const plugins = pluginManager();\n  const stateResolver = resolveManager();\n  const callbacks = {\n    [BOTUI_BLOCK_TYPES.MESSAGE]: () => {},\n    [BOTUI_BLOCK_TYPES.ACTION]: () => {}\n  };\n  const doCallback = (state = '', data) => {\n    const callback = callbacks[state];\n    callback(data);\n  };\n  const blocks = blockManager(history => {\n    doCallback(BOTUI_BLOCK_TYPES.MESSAGE, history);\n  });\n  const currentAction = actionManager(action => {\n    doCallback(BOTUI_BLOCK_TYPES.ACTION, action);\n  });\n  const botuiInterface = {\n    /**\n     * Add, update or remove messages.\n     */\n    message: {\n      /**\n       * Add a new non-action block to the chat list\n       */\n      add: (data = {\n        text: ''\n      }, meta) => {\n        return new Promise(resolve => {\n          stateResolver.set(resolve);\n          const key = blocks.add(plugins.runWithPlugins(createBlock(BOTUI_BLOCK_TYPES.MESSAGE, meta, data)));\n          stateResolver.resolve(key);\n        });\n      },\n      /**\n       * Get all of the current blocks listed in the chat.\n       */\n      getAll: () => Promise.resolve(blocks.getAll()),\n      /**\n       * Load existing list of blocks\n       */\n      setAll: newBlocks => {\n        blocks.setAll(newBlocks);\n        return Promise.resolve(blocks.getAll());\n      },\n      /**\n       * Get a single block by it's key.\n       */\n      get: (key = 0) => Promise.resolve(blocks.get(key)),\n      /**\n       * Remove a single block by it's key.\n       */\n      remove: (key = 0) => {\n        blocks.remove(key);\n        return Promise.resolve();\n      },\n      /**\n       * @param {BlockData} data an object with any values you want on the block\n       * Update a single block by it's key.\n       */\n      update: (key = 0, data = {}, meta) => {\n        const existingBlock = blocks.get(key);\n        const newMeta = meta ? Object.assign(Object.assign({}, existingBlock.meta), meta) : existingBlock.meta;\n        const newData = data ? Object.assign(Object.assign({}, existingBlock.data), data) : existingBlock.data;\n        blocks.update(key, plugins.runWithPlugins(createBlock(BOTUI_BLOCK_TYPES.MESSAGE, newMeta, newData, key)));\n        return Promise.resolve();\n      },\n      /**\n       * Removes all the blocks.\n       */\n      removeAll: () => {\n        blocks.clear();\n        return Promise.resolve();\n      }\n    },\n    action: {\n      /**\n       * Asks the user to perform an action. BotUI won't go further until\n       * this action is resolved by calling `.next()`\n       */\n      set: (data = {}, meta) => {\n        return new Promise(resolve => {\n          const action = createBlock(BOTUI_BLOCK_TYPES.ACTION, meta, data);\n          currentAction.set(action);\n          stateResolver.set((resolvedData, resolvedMeta) => {\n            currentAction.clear();\n            if (meta.ephemeral !== true) {\n              // ephemeral = short-lived\n              blocks.add(plugins.runWithPlugins(createBlock(BOTUI_BLOCK_TYPES.MESSAGE, Object.assign(Object.assign({}, resolvedMeta), {\n                previous: action\n              }), resolvedData)));\n            }\n            resolve(resolvedData);\n          });\n        });\n      },\n      /**\n       * Returns the current action or null if there is none.\n       * @returns {Promise<Block>}\n       */\n      get: () => {\n        return Promise.resolve(currentAction.get());\n      }\n    },\n    /**\n     * Wait does not let the next message/action resolve until .next() is called.\n     * When `waitTime` property is present in the meta, .next() is called internally with that meta.\n     */\n    wait: (waitOptions, forwardData, forwardMeta) => {\n      const meta = {\n        waiting: true,\n        ephemeral: true // to not add to the message history. see action.set for its usage.\n      };\n      if (waitOptions === null || waitOptions === void 0 ? void 0 : waitOptions.waitTime) {\n        setTimeout(() => botuiInterface.next(forwardData, forwardMeta), waitOptions.waitTime);\n      }\n      return botuiInterface.action.set({}, meta);\n    },\n    /**\n     * Add a listener for a BlockType.\n     */\n    onChange: (state, cb) => {\n      callbacks[state] = cb;\n      return botuiInterface;\n    },\n    /**\n     * Resolves current action or wait command. Passed data is sent to the next .then()\n     */\n    next: (...args) => {\n      stateResolver.resolve(...args);\n      return botuiInterface;\n    },\n    /**\n    * Register a plugin to manipulate block data.\n    * Example:\n    * The plugin below replaces `!(text)` with `<i>text</i>`\n    ```\n      .use(block => {\n        if (block.type == BOTUI_BLOCK_TYPES.MESSAGE) {\n          block.data.text = block.data?.text?.replace(/!\\(([^\\)]+)\\)/igm, \"<i>$1</i>\")\n        }\n        return block\n      })\n    ```\n    */\n    use: plugin => {\n      plugins.registerPlugin(plugin);\n      return botuiInterface;\n    }\n  };\n  return botuiInterface;\n};","map":{"version":3,"names":["createBlock","blockManager","resolveManager","pluginManager","actionManager","BlockTypes","BOTUI_BLOCK_TYPES","createBot","plugins","stateResolver","callbacks","MESSAGE","ACTION","doCallback","state","data","callback","blocks","history","currentAction","action","botuiInterface","message","add","text","meta","Promise","resolve","set","key","runWithPlugins","getAll","setAll","newBlocks","get","remove","update","existingBlock","newMeta","Object","assign","newData","removeAll","clear","resolvedData","resolvedMeta","ephemeral","previous","wait","waitOptions","forwardData","forwardMeta","waiting","waitTime","setTimeout","next","onChange","cb","args","use","plugin","registerPlugin"],"sources":["/Users/appletech/Desktop/chatbottest/chatbottest/node_modules/botui/dist/botui.js"],"sourcesContent":["import { createBlock, blockManager } from './block.js'; // even though the file has .ts extension, we need to use .js for resolution.\nimport { resolveManager } from './resolve.js';\nimport { pluginManager } from './plugin.js';\nimport { actionManager } from './action.js';\nexport var BlockTypes;\n(function (BlockTypes) {\n    BlockTypes[\"ACTION\"] = \"action\";\n    BlockTypes[\"MESSAGE\"] = \"message\";\n})(BlockTypes = BlockTypes || (BlockTypes = {}));\nexport const BOTUI_BLOCK_TYPES = BlockTypes;\nexport const createBot = () => {\n    const plugins = pluginManager();\n    const stateResolver = resolveManager();\n    const callbacks = {\n        [BOTUI_BLOCK_TYPES.MESSAGE]: () => { },\n        [BOTUI_BLOCK_TYPES.ACTION]: () => { },\n    };\n    const doCallback = (state = '', data) => {\n        const callback = callbacks[state];\n        callback(data);\n    };\n    const blocks = blockManager((history) => {\n        doCallback(BOTUI_BLOCK_TYPES.MESSAGE, history);\n    });\n    const currentAction = actionManager((action) => {\n        doCallback(BOTUI_BLOCK_TYPES.ACTION, action);\n    });\n    const botuiInterface = {\n        /**\n         * Add, update or remove messages.\n         */\n        message: {\n            /**\n             * Add a new non-action block to the chat list\n             */\n            add: (data = { text: '' }, meta) => {\n                return new Promise((resolve) => {\n                    stateResolver.set(resolve);\n                    const key = blocks.add(plugins.runWithPlugins(createBlock(BOTUI_BLOCK_TYPES.MESSAGE, meta, data)));\n                    stateResolver.resolve(key);\n                });\n            },\n            /**\n             * Get all of the current blocks listed in the chat.\n             */\n            getAll: () => Promise.resolve(blocks.getAll()),\n            /**\n             * Load existing list of blocks\n             */\n            setAll: (newBlocks) => {\n                blocks.setAll(newBlocks);\n                return Promise.resolve(blocks.getAll());\n            },\n            /**\n             * Get a single block by it's key.\n             */\n            get: (key = 0) => Promise.resolve(blocks.get(key)),\n            /**\n             * Remove a single block by it's key.\n             */\n            remove: (key = 0) => {\n                blocks.remove(key);\n                return Promise.resolve();\n            },\n            /**\n             * @param {BlockData} data an object with any values you want on the block\n             * Update a single block by it's key.\n             */\n            update: (key = 0, data = {}, meta) => {\n                const existingBlock = blocks.get(key);\n                const newMeta = meta\n                    ? Object.assign(Object.assign({}, existingBlock.meta), meta) : existingBlock.meta;\n                const newData = data\n                    ? Object.assign(Object.assign({}, existingBlock.data), data) : existingBlock.data;\n                blocks.update(key, plugins.runWithPlugins(createBlock(BOTUI_BLOCK_TYPES.MESSAGE, newMeta, newData, key)));\n                return Promise.resolve();\n            },\n            /**\n             * Removes all the blocks.\n             */\n            removeAll: () => {\n                blocks.clear();\n                return Promise.resolve();\n            },\n        },\n        action: {\n            /**\n             * Asks the user to perform an action. BotUI won't go further until\n             * this action is resolved by calling `.next()`\n             */\n            set: (data = {}, meta) => {\n                return new Promise((resolve) => {\n                    const action = createBlock(BOTUI_BLOCK_TYPES.ACTION, meta, data);\n                    currentAction.set(action);\n                    stateResolver.set((resolvedData, resolvedMeta) => {\n                        currentAction.clear();\n                        if (meta.ephemeral !== true) {\n                            // ephemeral = short-lived\n                            blocks.add(plugins.runWithPlugins(createBlock(BOTUI_BLOCK_TYPES.MESSAGE, Object.assign(Object.assign({}, resolvedMeta), { previous: action }), resolvedData)));\n                        }\n                        resolve(resolvedData);\n                    });\n                });\n            },\n            /**\n             * Returns the current action or null if there is none.\n             * @returns {Promise<Block>}\n             */\n            get: () => {\n                return Promise.resolve(currentAction.get());\n            },\n        },\n        /**\n         * Wait does not let the next message/action resolve until .next() is called.\n         * When `waitTime` property is present in the meta, .next() is called internally with that meta.\n         */\n        wait: (waitOptions, forwardData, forwardMeta) => {\n            const meta = {\n                waiting: true,\n                ephemeral: true, // to not add to the message history. see action.set for its usage.\n            };\n            if (waitOptions === null || waitOptions === void 0 ? void 0 : waitOptions.waitTime) {\n                setTimeout(() => botuiInterface.next(forwardData, forwardMeta), waitOptions.waitTime);\n            }\n            return botuiInterface.action.set({}, meta);\n        },\n        /**\n         * Add a listener for a BlockType.\n         */\n        onChange: (state, cb) => {\n            callbacks[state] = cb;\n            return botuiInterface;\n        },\n        /**\n         * Resolves current action or wait command. Passed data is sent to the next .then()\n         */\n        next: (...args) => {\n            stateResolver.resolve(...args);\n            return botuiInterface;\n        },\n        /**\n        * Register a plugin to manipulate block data.\n        * Example:\n        * The plugin below replaces `!(text)` with `<i>text</i>`\n        ```\n          .use(block => {\n            if (block.type == BOTUI_BLOCK_TYPES.MESSAGE) {\n              block.data.text = block.data?.text?.replace(/!\\(([^\\)]+)\\)/igm, \"<i>$1</i>\")\n            }\n            return block\n          })\n        ```\n        */\n        use: (plugin) => {\n            plugins.registerPlugin(plugin);\n            return botuiInterface;\n        },\n    };\n    return botuiInterface;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}